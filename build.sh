#!/usr/bin/env bash

author='Mitsuhiro Nakamura'
email='m.nacamura@gmail.com'
homepage='https://github.com/mnacamura/vim-gauche'

readonly author email homepage

read -r -d '' common_meta <<EOF
" Language: Scheme (Gauche)
" Last Change: $(date +"%Y-%m-%d")
" Author: $author <$email>
" URL: $homepage
" License: Public domain
" Notes: To enable this plugin, set filetype=scheme and (b|g):is_gauche=1.
EOF

set -euo pipefail

show_usage() {
    cat >&2 <<-EOF
	Usage: $0 CMD [ARG...]
        
	Commands:
	    atdef
	    macro
	    specialform
	    function
	    variable
	    constant
	    comparator
	    module
	    class
	    syntax
	    ftplugin
	EOF
}

esc() {
    echo "$1" | sed -E 's@(\?|\*|\+|\.|\^|\$)@\\\1@g'
}

build_atdef() {
    if [ -z "${1+defined}" ]; then
        echo " Usage: $0 atdef [FILE...], where FILE is texi files in gauche src path" >&2
        exit 1
    fi

    grep -E '^@def' "$@" \
        | sed 's/:/ /' \
        | awk '{ sub(".*/", "", $1); print }' \
        | sort | uniq
}

build_macro() {
    if [ -z "${1+defined}" ]; then
        echo " Usage: $0 macro FILE, where FILE is generated by $0 atdef" >&2
        exit 1
    fi

    local line name
    awk '/@defmacx?/ {
             if ( $1 ~ /(core|macro|object)/ ) { print "Builtin", $3 }
             else if ( $1 ~ /gauche/ ) { print "Ext", $3 }
             else if ( $1 ~ /r7rs/ ) { print "R7rs", $3 }
             else if ( $1 ~ /srfi/ ) { print "Srfi", $3 }
             else if ( $1 ~ /util/ ) { print "Util", $3 }
         }' "$1" \
        | sort | uniq \
        | while read -r line; do
              name="$(echo "$line" | awk '{ print $2 }')"
              if ! grep -E "syn keyword scheme\\w*Syntax $(esc "$name")" \
                  "$VIM_SRC"/runtime/syntax/scheme.vim > /dev/null 2>&1
              then
                  echo "$line"
              fi
          done \
        | awk '{ if ( $2 == "use" ) {
                     # skip it as it is handled in schemeImport
                 } else if ( $2 == "^c" ) {
                     print "syn match gauche"$1"Macro /\\^[_a-z]/"
                 } else {
                     print "syn keyword gauche"$1"Macro", $2
                 }
               }'
}

build_specialform() {
    if [ -z "${1+defined}" ]; then
        echo " Usage: $0 specialform FILE, where FILE is generated by $0 atdef" >&2
        exit 1
    fi

    local line name
    awk '/@defspecx?/ {
             if ( $1 ~ /(core|macro|object)/ ) { print "Builtin", $3 }
             else if ( $1 ~ /gauche/ ) { print "Ext", $3 }
             else if ( $1 ~ /r7rs/ ) { print "R7rs", $3 }
             else if ( $1 ~ /srfi/ ) { print "Srfi", $3 }
             else if ( $1 ~ /util/ ) { print "Util", $3 }
         }' "$1" \
        | sort | uniq \
        | while read -r line; do
              name="$(echo "$line" | awk '{ print $2 }')"
              if ! grep -E "syn keyword scheme\\w*Syntax $(esc "$name")" \
                  "$VIM_SRC"/runtime/syntax/scheme.vim > /dev/null 2>&1
              then
                  echo "$line"
              fi
          done \
        | awk '{ if ( $2 == "import" ) {
                     # skip it as it is handled in schemeImport
                 } else {
                     print "syn keyword gauche"$1"SpecialForm", $2
                 }
               }'
}

build_function() {
    if [ -z "${1+defined}" ]; then
        echo " Usage: $0 function FILE, where FILE is generated by $0 atdef" >&2
        exit 1
    fi

    local line name
    awk 'function fname(line,    words) {
             if ( match(line, /{\(setter (.+)\)}/, m) ) { return m[1] }
             else { split(line, words); return words[3] }
         }
         /@defunx?/ {
             if ( $1 ~ /(core|macro|object)/ ) { print "Builtin", fname($0) }
             else if ( $1 ~ /gauche/ ) { print "Ext", fname($0) }
             else if ( $1 ~ /r7rs/ ) { print "R7rs", fname($0) }
             else if ( $1 ~ /srfi/ ) { print "Srfi", fname($0) }
             else if ( $1 ~ /util/ ) { print "Util", fname($0) }
         }' "$1" \
        | sort | uniq \
        | while read -r line; do
              name="$(echo "$line" | awk '{ print $2 }')"
              if ! grep -E "syn keyword schemeFunction $(esc "$name")" \
                  "$VIM_SRC"/runtime/syntax/scheme.vim > /dev/null 2>&1
              then
                  echo "$line"
              fi
          done \
        | awk '{ print "syn keyword gauche"$1"Function", $2 }'
}

build_variable() {
    if [ -z "${1+defined}" ]; then
        echo " Usage: $0 variable FILE, where FILE is generated by $0 atdef" >&2
        exit 1
    fi

    local line name
    awk '/@defvarx?/ {
             if ( $1 ~ /(core|macro|object)/ ) { print "Builtin", $3 }
             else if ( $1 ~ /gauche/ ) { print "Ext", $3 }
             else if ( $1 ~ /r7rs/ ) { print "R7rs", $3 }
             else if ( $1 ~ /srfi/ ) { print "Srfi", $3 }
             else if ( $1 ~ /util/ ) { print "Util", $3 }
         }' "$1" \
        | sort | uniq \
        | while read -r line; do
              name="$(echo "$line" | awk '{ print $2 }')"
              if ! grep -E "syn keyword schemeConstant $(esc "$name")" \
                  "$VIM_SRC"/runtime/syntax/scheme.vim > /dev/null 2>&1
              then
                  echo "$line"
              fi
          done \
        | awk 'BEGIN {
                   at[0] = "u8"; at[1] = "s8";
                   at[2] = "u16"; at[3] = "s16";
                   at[4] = "u32"; at[5] = "s32";
                   at[6] = "u64"; at[7] = "s64";
                   at[8] = "f16"; at[9] = "f32"; at[10] = "f64";
                   at[11] = "c32";  at[12] = "c64"; at[12] = "c128";
               }
               { if ( /@@/ ) {
                     for (i in at) {
                         line = $0
                         sub(/@@/, at[i], line)
                         print line
                     }
                 } else { print }
               }' \
        | awk '{ print "syn keyword gauche"$1"Variable", $2 }'
}

build_constant() {
    if [ -z "${1+defined}" ]; then
        echo " Usage: $0 constant FILE, where FILE is generated by $0 atdef" >&2
        exit 1
    fi

    local line name
    awk '/@defvrx? {Constant}/ {
             if ( $1 ~ /(core|macro|object)/ ) { print "Builtin", $4 }
             else if ( $1 ~ /gauche/ ) { print "Ext", $4 }
             else if ( $1 ~ /r7rs/ ) { print "R7rs", $4 }
             else if ( $1 ~ /srfi/ ) { print "Srfi", $4 }
             else if ( $1 ~ /util/ ) { print "Util", $4 }
         }' "$1" \
        | sort | uniq \
        | while read -r line; do
              name="$(echo "$line" | awk '{ print $2 }')"
              if ! grep -E "syn keyword schemeConstant $(esc "$name")" \
                  "$VIM_SRC"/runtime/syntax/scheme.vim > /dev/null 2>&1
              then
                  echo "$line"
              fi
          done \
        | awk '{ print "syn keyword gauche"$1"Constant", $2 }'
}

build_comparator() {
    if [ -z "${1+defined}" ]; then
        echo " Usage: $0 comparator FILE, where FILE is generated by $0 atdef" >&2
        exit 1
    fi

    local line name
    awk '/@defvrx? {Comparator}/ {
             if ( $1 ~ /(core|macro|object)/ ) { print "Builtin", $4 }
             else if ( $1 ~ /gauche/ ) { print "Ext", $4 }
             else if ( $1 ~ /r7rs/ ) { print "R7rs", $4 }
             else if ( $1 ~ /srfi/ ) { print "Srfi", $4 }
             else if ( $1 ~ /util/ ) { print "Util", $4 }
         }' "$1" \
        | sort | uniq \
        | while read -r line; do
              name="$(echo "$line" | awk '{ print $2 }')"
              if ! grep -E "syn keyword schemeConstant $(esc "$name")" \
                  "$VIM_SRC"/runtime/syntax/scheme.vim > /dev/null 2>&1
              then
                  echo "$line"
              fi
          done \
        | awk '{ print "syn keyword gauche"$1"Comparator", $2 }'
}

build_module() {
    if [ -z "${1+defined}" ]; then
        echo " Usage: $0 module FILE, where FILE is generated by $0 atdef" >&2
        exit 1
    fi

    local line name
    awk 'function mname(line,    words) {
             split(line, words)
             if ( words[4] ~ /}$/ ) { return words[5] }
             else { return words[4] }
         }
         /@deftpx? {(Builtin )?Module}/ {
             if ( $1 ~ /(core|macro|object)/ ) { print "Builtin", mname($0) }
             else if ( $1 ~ /gauche/ ) { print "Ext", mname($0) }
             else if ( $1 ~ /r7rs/ ) { print "R7rs", mname($0) }
             else if ( $1 ~ /srfi/ ) { print "Srfi", mname($0) }
             else if ( $1 ~ /util/ ) { print "Util", mname($0) }
         }' "$1" \
        | sort | uniq \
        | awk '{ print "syn keyword gauche"$1"Module", $2 }'
}

build_class() {
    if [ -z "${1+defined}" ]; then
        echo " Usage: $0 class FILE, where FILE is generated by $0 atdef" >&2
        exit 1
    fi

    local line name
    awk 'function kname(line,    words) {
             split(line, words)
             if ( words[4] ~ /}$/ ) { return words[5] }
             else { return words[4] }
         }
         /@deftpx? {((Builtin )?Class|Metaclass)}/ {
             if ( $1 ~ /(core|macro|object)/ ) { print "Builtin", kname($0) }
             else if ( $1 ~ /gauche/ ) { print "Ext", kname($0) }
             else if ( $1 ~ /r7rs/ ) { print "R7rs", kname($0) }
             else if ( $1 ~ /srfi/ ) { print "Srfi", kname($0) }
             else if ( $1 ~ /util/ ) { print "Util", kname($0) }
         }' "$1" \
        | sort | uniq \
        | awk '{ print "syn keyword gauche"$1"Class", $2 }'
}

build_syntax() {
    if [ "$#" -eq 0 ]; then
        echo " Usage: $0 syntax [FILE...], where FILE is generated by $0 macro etc." >&2
        exit 1
    fi

    cat <<-EOF
	" Vim syntax file
	$common_meta
	
	if !exists('b:did_scheme_syntax')
	  finish
	endif
	EOF

    echo
    cat <<-'EOF'
	syn region schemeImport matchgroup=schemeImport start="\(([ \t\n]*\)\@<=\(import\|use\)\>" end=")"me=e-1 contained contains=schemeImportForm,schemeIdentifier,schemeComment,schemeDatumComment,gaucheBuiltinModule,gaucheExtModule,gaucheUtilModule
	
	syn region gaucheSharpString start=/\(\\\)\@<!#"/ skip=/\\[\\"]/ end=/"/ contains=gaucheSharpStringUnquote
	hi def link gaucheSharpString schemeString
	
	syn region gaucheSharpStringUnquote matchgroup=schemeParentheses start=/\(\~\)\@<!\~\(\~\)\@!/ end=/[ `'\t\n\[\]()";]/me=e-1 contained contains=ALLBUT,schemeDatumCommentForm,@schemeImportCluster
	syn region gaucheSharpStringUnquote matchgroup=schemeParentheses start=/\(\~\)\@<!\~#\?(/ end=/)/ contained contains=ALLBUT,schemeDatumCommentForm,@schemeImportCluster
	syn region gaucheSharpStringUnquote matchgroup=schemeParentheses start=/\(\~\)\@<!\~\[/ end=/\]/ contained contains=ALLBUT,schemeDatumCommentForm,@schemeImportCluster
	EOF

    local file
    for file in "$@"; do
        echo
        cat "$file"
    done

    echo
    cat <<-EOF
	hi def link gaucheBuiltinMacro schemeSyntax
	hi def link gaucheBuiltinSpecialForm schemeSpecialSyntax
	hi def link gaucheBuiltinFunction schemeFunction
	hi def link gaucheBuiltinVariable schemeConstant
	hi def link gaucheBuiltinConstant schemeConstant
	hi def link gaucheBuiltinComparator schemeConstant
	hi def link gaucheBuiltinModule Type
	
	hi def link gaucheExtMacro schemeSyntax
	hi def link gaucheExtSpecialForm schemeSpecialSyntax
	hi def link gaucheExtFunction schemeFunction
	hi def link gaucheExtVariable schemeConstant
	hi def link gaucheExtConstant schemeConstant
	hi def link gaucheExtComparator schemeConstant
	hi def link gaucheExtModule Type
	
	hi def link gaucheUtilMacro schemeSyntax
	hi def link gaucheUtilSpecialForm schemeSpecialSyntax
	hi def link gaucheUtilFunction schemeFunction
	hi def link gaucheUtilVariable schemeConstant
	hi def link gaucheUtilConstant schemeConstant
	hi def link gaucheUtilComparator schemeConstant
	hi def link gaucheUtilModule Type
	EOF
}

build_ftplugin() {
    if [ "$#" -eq 0 ]; then
        echo " Usage: $0 ftplugin [FILE...], where FILE is generated by $0 macro etc." >&2
        exit 1
    fi

    cat <<-EOF
	" Vim filetype plugin file
	$common_meta
	
	if !exists('b:did_scheme_ftplugin')
	  finish
	endif
	
	EOF

    local word
    awk '{ print $4 }' "$@" \
        | awk '/^(|r|g)let((|rec)(|1|\*)($|-)|\/)/ || /-let(|rec)(|1|\*)$/ \
            || /^define($|-)/ || /-define$/ \
            || /^match($|-)/ || /-match$/ \
            || /^(|e)case($|-)/ || ( /-(|e)case$/ && $0 !~ /(lower|upper|title)-case$/ ) \
            || /^lambda($|-)/ || ( /-lambda(|\*)$/ && $0 !~ /^scheme\.case-lambda$/ ) \
            || /^set!($|-)/ || ( /-set!$/ && $0 !~ /char-set!$/ ) \
            || /^do(-|times|list)/' \
        | sort \
        | uniq \
        | while read -r word; do
        if ! grep -F "setl lispwords+=$word" \
            "$VIM_SRC"/runtime/ftplugin/scheme.vim > /dev/null 2>&1
        then
            echo "setl lispwords+=$word"
        fi
    done
}

if [ -z "${VIM_SRC+defined}" ]; then
    echo "Please set VIM_SRC to vim source path" >&2
    exit 1
fi

if [ -z "${1+defined}" ]; then
    show_usage
    exit 1
fi

case "$1" in
    atdef)
        shift
        build_atdef "$@"
        ;;
    macro)
        shift
        build_macro "$@"
        ;;
    specialform)
        shift
        build_specialform "$@"
        ;;
    function)
        shift
        build_function "$@"
        ;;
    variable)
        shift
        build_variable "$@"
        ;;
    constant)
        shift
        build_constant "$@"
        ;;
    comparator)
        shift
        build_comparator "$@"
        ;;
    module)
        shift
        build_module "$@"
        ;;
    class)
        shift
        build_class "$@"
        ;;
    syntax)
        shift
        build_syntax "$@"
        ;;
    ftplugin)
        shift
        build_ftplugin "$@"
        ;;
    *)
        show_usage
        exit 1
        ;;
esac
