#!/usr/bin/env bash

set -euo pipefail

TMPD="$(mktemp -d --suffix vimgauche)"
readonly TMPD
cleanup() { rm -rf "$TMPD"; }
trap cleanup ERR SIGTERM EXIT

readonly LIB="$TMPD/lib.awk"

main() {
    if [[ -z "${GAUCHE_SRC+defined}" ]]; then
        echo "Please set GAUCHE_SRC to gauche source path" >&2
        exit 1
    fi

    if [[ -z "${1+defined}" ]]; then
        usage
    fi

    local cmd
    case "$1" in
        ( cise \
        | syntax \
        | ftplugin \
        )
            cmd="$1"
            shift
            build_"$cmd" "$@"
            ;;
        (*)
            usage
            ;;
    esac
}

usage() {
    cat >&2 <<EOF
Usage: $0 CMD [ARG...]

Commands:
    cise
    syntax
    ftplugin
EOF
    exit 1
}

build_cise() {
    if [[ -z "${1+defined}" ]]; then
        cat >&2 <<EOF
Usage: $0 cise TSV

Generate vim syntax for Gauche CiSE statements, expressions, types, and stub forms.

Args:
    TSV         TSV file generated by $0 tsv
EOF
        exit 1
    fi

    gawk -F'\t' '$3 ~ /^{cise type}$/ { print $4 }' "$1" \
        | sort | uniq \
        | gawk '{ switch ($0) {
                  default:
                      print "syn keyword r7rsCiSEType", $0
                      break
                  }
                }'
    gawk -F'\t' '$3 ~ /^{cise statement}$/ || $3 ~ /^{stub form}$/ { print $4 }' "$1" \
        | sort | uniq \
        | find_undefined_keywords_in 'r7rs\w*SyntaxM?' \
        | gawk '{ switch ($0) {
                  case /(define|decl)/:
                      # Use special color
                      print "syn keyword r7rsCiSESyntaxM", $0
                      break
                  # != contains ! but not mutator
                  case /!$/:
                      # Use special color
                      print "syn keyword r7rsCiSESyntaxM", $0
                      break
                  default:
                      print "syn keyword r7rsCiSESyntax", $0
                      break
                  }
                }'
    gawk -F'\t' '$3 ~ /^{cise expression}$/ { print $4 }' "$1" \
        | sort | uniq \
        | find_undefined_keywords_in 'r7rs(\w*Syntax|Function)M?' \
        | gawk '{ switch ($0) {
                  # != contains ! but not mutator
                  case /!$/:
                      # Use special color
                      print "syn keyword r7rsCiSEFunctionM", $0
                      break
                  default:
                      print "syn keyword r7rsCiSEFunction", $0
                      break
                  }
                }'
}

build_syntax() {
    if [[ -z "${1+defined}" ]]; then
        cat >&2 <<EOF
Usage: $0 syntax PATH [VIM...]

Rebuild syntax/gauche.vim from generated vim files.

Args:
    PATH        path to syntax/gauche.vim
    VIM...      files generated by $0 (macro|specialform|...)
EOF
        exit 1
    fi

    local path="$1"
    shift

    local tmp="$TMPD/syntax.vim"
    {
        sed -n '1, /^" Common expressions {{{1$/ p' "$path" | update_timestamp
        echo
        cat "$@" | sort | uniq
        echo
        sed -n '/^" Special expressions {{{1$/, $ p' "$path"
    } > "$tmp"
    cp "$tmp" "$path"
}

build_ftplugin() {
    if [[ -z "${1+defined}" ]]; then
        cat >&2 <<EOF
Usage: $0 ftplugin PATH TSV

Rebuild ftplugin/gauche.vim from generated vim files.

Args:
    PATH        path to ftplugin/gauche.vim
    TSV         TSV file generated by $0 tsv
EOF
        exit 1
    fi

    local path="$1" tsv="$2"
    shift 2

    local tmp="$TMPD/ftplugin.vim"
    {
        sed -n '1, /^" lispwords {{{$/ p' "$path" | update_timestamp
        echo
        gawk '$4 ~ /lispword/ { print $3 }' "$tsv" \
            | sort | uniq \
            | find_undefined_lispwords \
            | sed -E 's/(.*)/setl lispwords+=\1/'
        echo
        sed -n '/^" }}}$/, $ p' "$path"
    } > "$tmp"
    cp "$tmp" "$path"
}

update_timestamp() {
    sed -E 's/^(.*Last Change: )[0-9]{4}-[0-9]{2}-[0-9]{2}$/\1'"$(date +%Y-%m-%d)/"
}

find_undefined_keywords_in() {
    local groupname="$1" keyword
    while read -r keyword; do
        if ! grep -E "syn keyword $groupname (.+ )?$(esc "$keyword")( |$)" \
               ./syntax/r7rs{,-large}.vim > /dev/null 2>&1
        then
            echo "$keyword"
        fi
    done
}

find_undefined_lispwords() {
    local lispword
    while read -r lispword; do
        if ! grep -E "setl lispwords\+?=(.+,)?$(esc "$lispword")(,|$)" \
               ./ftplugin/r7rs.vim > /dev/null 2>&1
        then
            echo "$lispword"
        fi
    done
}

# Escape meta characters in EXTENDED regular expressions
esc() {
    echo "$1" | sed -E 's@(\*|\.|\^|\$|\+|\?)@\\\1@g'
}

cat > "$LIB" <<'EOF'
BEGIN {
    FS = "\t"
    OFS = "\t"
}
EOF

main "$@"
