#!/usr/bin/env bash

author='Mitsuhiro Nakamura'
email='m.nacamura@gmail.com'
homepage='https://github.com/mnacamura/vim-gauche'

readonly author email homepage

read -r -d '' common_meta <<EOF
" Language: Scheme (Gauche)
" Last Change: $(date +"%Y-%m-%d")
" Author: $author <$email>
" URL: $homepage
" License: Public domain
" Notes: To enable this plugin, set filetype=scheme and (b|g):is_gauche=1.
EOF

set -euo pipefail

show_usage() {
    cat >&2 <<EOF
Usage: $0 CMD [ARG...]

Commands:
    atdef
    macro
    specialform
    function
    variable
    constant
    comparator
    module
    class
    syntax
    ftplugin
EOF
}

esc() {
    echo "$1" | sed -E 's@(\?|\*|\+|\.|\^|\$)@\\\1@g'
}

build_atdef() {
    if [ -z "${1+defined}" ]; then
        cat >&2 <<EOF
Usage: $0 atdef [NAME...]

Args:
    NAME...     texinfo file name(s) shipped with Gauche's source
EOF
        exit 1
    fi

    local name files=()
    for name in "$@"; do
        files+=("$GAUCHE_SRC/doc/${name/.texi/}.texi")
    done

    grep -E '^@def' "${files[@]}" \
        | sed 's/:/ /' \
        | awk -f "$awklib" -e '{ $1 = basename($1); print }' \
        | sort | uniq
}

build_macro() {
    if [ -z "${1+defined}" ]; then
        cat >&2 <<EOF
Usage: $0 macro FILE

Args:
    FILE        path to the file generated by $0 atdef
EOF
        exit 1
    fi

    local line name
    awk -f "$awklib" -e '/@defmacx?/ { print libtype($1), $3 }' "$1" \
        | sort | uniq \
        | while read -r line; do
              name="$(echo "$line" | awk '{ print $2 }')"
              if ! grep -E "syn keyword scheme\\w*Syntax $(esc "$name")" \
                  "$VIM_SRC"/runtime/syntax/scheme.vim > /dev/null 2>&1
              then
                  echo "$line"
              fi
          done \
        | awk '{ if ( $2 == "use" ) {
                     # skip it as it is handled in schemeImport
                 } else if ( $2 == "^c" ) {
                     print "syn match gauche"$1"Macro /\\^[_a-z]/"
                 } else {
                     print "syn keyword gauche"$1"Macro", $2
                 }
               }'
}

build_specialform() {
    if [ -z "${1+defined}" ]; then
        cat >&2 <<EOF
Usage: $0 specialform FILE

Args:
    FILE        path to the file generated by $0 atdef
EOF
        exit 1
    fi

    local line name
    awk -f "$awklib" -e '/@defspecx?/ { print libtype($1), $3 }' "$1" \
        | sort | uniq \
        | while read -r line; do
              name="$(echo "$line" | awk '{ print $2 }')"
              if ! grep -E "syn keyword scheme\\w*Syntax $(esc "$name")" \
                  "$VIM_SRC"/runtime/syntax/scheme.vim > /dev/null 2>&1
              then
                  echo "$line"
              fi
          done \
        | awk '{ if ( $2 == "import" ) {
                     # skip it as it is handled in schemeImport
                 } else {
                     print "syn keyword gauche"$1"SpecialForm", $2
                 }
               }'
}

build_function() {
    if [ -z "${1+defined}" ]; then
        cat >&2 <<EOF
Usage: $0 function FILE

Args:
    FILE        path to the file generated by $0 atdef
EOF
        exit 1
    fi

    local line name
    awk -f "$awklib" -e '/@defunx?/ { print libtype($1), fname($0) }' "$1" \
        | sort | uniq \
        | while read -r line; do
              name="$(echo "$line" | awk '{ print $2 }')"
              if ! grep -E "syn keyword schemeFunction $(esc "$name")" \
                  "$VIM_SRC"/runtime/syntax/scheme.vim > /dev/null 2>&1
              then
                  echo "$line"
              fi
          done \
        | awk '{ print "syn keyword gauche"$1"Function", $2 }'
}

build_variable() {
    if [ -z "${1+defined}" ]; then
        cat >&2 <<EOF
Usage: $0 variable FILE

Args:
    FILE        path to the file generated by $0 atdef
EOF
        exit 1
    fi

    local line name
    awk -f "$awklib" -e '/@defvarx?/ { print libtype($1), $3 }' "$1" \
        | sort | uniq \
        | while read -r line; do
              name="$(echo "$line" | awk '{ print $2 }')"
              if ! grep -E "syn keyword schemeConstant $(esc "$name")" \
                  "$VIM_SRC"/runtime/syntax/scheme.vim > /dev/null 2>&1
              then
                  echo "$line"
              fi
          done \
        | awk 'BEGIN {
                   at[0] = "u8"; at[1] = "s8";
                   at[2] = "u16"; at[3] = "s16";
                   at[4] = "u32"; at[5] = "s32";
                   at[6] = "u64"; at[7] = "s64";
                   at[8] = "f16"; at[9] = "f32"; at[10] = "f64";
                   at[11] = "c32";  at[12] = "c64"; at[12] = "c128";
               }
               { if ( /@@/ ) {
                     for (i in at) {
                         line = $0
                         sub(/@@/, at[i], line)
                         print line
                     }
                 } else { print }
               }' \
        | awk '{ print "syn keyword gauche"$1"Variable", $2 }'
}

build_constant() {
    if [ -z "${1+defined}" ]; then
        cat >&2 <<EOF
Usage: $0 constant FILE

Args:
    FILE        path to the file generated by $0 atdef
EOF
        exit 1
    fi

    local line name
    awk -f "$awklib" -e '/@defvrx? {Constant}/ { print libtype($1), $4 }' "$1" \
        | sort | uniq \
        | while read -r line; do
              name="$(echo "$line" | awk '{ print $2 }')"
              if ! grep -E "syn keyword schemeConstant $(esc "$name")" \
                  "$VIM_SRC"/runtime/syntax/scheme.vim > /dev/null 2>&1
              then
                  echo "$line"
              fi
          done \
        | awk '{ print "syn keyword gauche"$1"Constant", $2 }'
}

build_comparator() {
    if [ -z "${1+defined}" ]; then
        cat >&2 <<EOF
Usage: $0 comparator FILE

Args:
    FILE        path to the file generated by $0 atdef
EOF
        exit 1
    fi

    local line name
    awk -f "$awklib" -e '/@defvrx? {Comparator}/ { print libtype($1), $4 }' "$1" \
        | sort | uniq \
        | while read -r line; do
              name="$(echo "$line" | awk '{ print $2 }')"
              if ! grep -E "syn keyword schemeConstant $(esc "$name")" \
                  "$VIM_SRC"/runtime/syntax/scheme.vim > /dev/null 2>&1
              then
                  echo "$line"
              fi
          done \
        | awk '{ print "syn keyword gauche"$1"Comparator", $2 }'
}

build_module() {
    if [ -z "${1+defined}" ]; then
        cat >&2 <<EOF
Usage: $0 module FILE

Args:
    FILE        path to the file generated by $0 atdef
EOF
        exit 1
    fi

    local line name
    awk -f "$awklib" -e '/@deftpx? {(Builtin )?Module}/ {
                             print libtype($1), mname($0)
                         }' "$1" \
        | sort | uniq \
        | awk '{ print "syn keyword gauche"$1"Module", $2 }'
}

build_class() {
    if [ -z "${1+defined}" ]; then
        cat >&2 <<EOF
Usage: $0 class FILE

Args:
    FILE        path to the file generated by $0 atdef
EOF
        exit 1
    fi

    local line name
    awk -f "$awklib" -e '/@deftpx? {((Builtin )?Class|Metaclass)}/ {
                             print libtype($1), kname($0)
                         }' "$1" \
        | sort | uniq \
        | awk '{ print "syn keyword gauche"$1"Class", $2 }'
}

build_syntax() {
    if [ "$#" -eq 0 ]; then
        cat >&2 <<EOF
Usage: $0 syntax [FILE...]

Args:
    FILE...     path to file(s) generated by $0 (macro|specialform|...)
EOF
        exit 1
    fi

    cat <<EOF
" Vim syntax file
$common_meta

if !exists('b:did_scheme_syntax')
  finish
endif
EOF

    echo
    cat <<'EOF'
syn region schemeImport matchgroup=schemeImport start="\(([ \t\n]*\)\@<=\(import\|use\)\>" end=")"me=e-1 contained contains=schemeImportForm,schemeIdentifier,schemeComment,schemeDatumComment,gaucheBuiltinModule,gaucheExtModule,gaucheUtilModule

syn region gaucheSharpString start=/\(\\\)\@<!#"/ skip=/\\[\\"]/ end=/"/ contains=gaucheSharpStringUnquote
hi def link gaucheSharpString schemeString

syn region gaucheSharpStringUnquote matchgroup=schemeParentheses start=/\(\~\)\@<!\~\(\~\)\@!/ end=/[ `'\t\n\[\]()";]/me=e-1 contained contains=ALLBUT,schemeDatumCommentForm,@schemeImportCluster
syn region gaucheSharpStringUnquote matchgroup=schemeParentheses start=/\(\~\)\@<!\~#\?(/ end=/)/ contained contains=ALLBUT,schemeDatumCommentForm,@schemeImportCluster
syn region gaucheSharpStringUnquote matchgroup=schemeParentheses start=/\(\~\)\@<!\~\[/ end=/\]/ contained contains=ALLBUT,schemeDatumCommentForm,@schemeImportCluster
EOF

    local file
    for file in "$@"; do
        echo
        cat "$file"
    done

    echo
    cat <<EOF
hi def link gaucheBuiltinMacro schemeSyntax
hi def link gaucheBuiltinSpecialForm schemeSpecialSyntax
hi def link gaucheBuiltinFunction schemeFunction
hi def link gaucheBuiltinVariable schemeConstant
hi def link gaucheBuiltinConstant schemeConstant
hi def link gaucheBuiltinComparator schemeConstant
hi def link gaucheBuiltinModule Type

hi def link gaucheExtMacro schemeSyntax
hi def link gaucheExtSpecialForm schemeSpecialSyntax
hi def link gaucheExtFunction schemeFunction
hi def link gaucheExtVariable schemeConstant
hi def link gaucheExtConstant schemeConstant
hi def link gaucheExtComparator schemeConstant
hi def link gaucheExtModule Type

hi def link gaucheUtilMacro schemeSyntax
hi def link gaucheUtilSpecialForm schemeSpecialSyntax
hi def link gaucheUtilFunction schemeFunction
hi def link gaucheUtilVariable schemeConstant
hi def link gaucheUtilConstant schemeConstant
hi def link gaucheUtilComparator schemeConstant
hi def link gaucheUtilModule Type
EOF
}

build_ftplugin() {
    if [ "$#" -eq 0 ]; then
        cat >&2 <<EOF
Usage: $0 ftplugin [FILE...]

Args:
    FILE...     path to file(s) generated by $0 (macro|specialform|...)
EOF
        exit 1
    fi

    cat <<EOF
" Vim filetype plugin file
$common_meta

if !exists('b:did_scheme_ftplugin')
  finish
endif

EOF

    local word
    awk '{ print $4 }' "$@" \
        | awk '/^(|r|g)let((|rec)(|1|\*)($|-)|\/)/ || /-let(|rec)(|1|\*)$/ \
            || /^define($|-)/ || /-define$/ \
            || /^match($|-)/ || /-match$/ \
            || /^(|e)case($|-)/ || ( /-(|e)case$/ && $0 !~ /(lower|upper|title)-case$/ ) \
            || /^lambda($|-)/ || ( /-lambda(|\*)$/ && $0 !~ /^scheme\.case-lambda$/ ) \
            || /^set!($|-)/ || ( /-set!$/ && $0 !~ /char-set!$/ ) \
            || /^do(-|times|list)/' \
        | sort \
        | uniq \
        | while read -r word; do
        if ! grep -F "setl lispwords+=$word" \
            "$VIM_SRC"/runtime/ftplugin/scheme.vim > /dev/null 2>&1
        then
            echo "setl lispwords+=$word"
        fi
    done
}

if [ -z "${GAUCHE_SRC+defined}" ]; then
    echo "Please set GAUCHE_SRC to gauche source path" >&2
    exit 1
fi

if [ -z "${VIM_SRC+defined}" ]; then
    echo "Please set VIM_SRC to vim source path" >&2
    exit 1
fi

if [ -z "${1+defined}" ]; then
    show_usage
    exit 1
fi

awklib="$(mktemp --suffix vimgauche)"
cat > "$awklib" <<'EOF'
function basename(path,    _path) {
    _path = path
    sub(".*/", "", _path)
    return _path
}
function libtype(texifile) {
    if ( texifile ~ /(core|macro|object)/ )
        return "Builtin"
    if ( texifile ~ /gauche/ )
        return "Ext"
    if ( texifile ~ /r7rs/ )
        return "R7rs"
    if ( texifile ~ /srfi/ )
        return "Srfi"
    if ( texifile ~ /util/ )
        return "Util"
    return "Unknown"
}
function fname(line,    words) {
    if ( match(line, /{\(setter (.+)\)}/, m) ) { return m[1] }
    else { split(line, words); return words[3] }
}
function mname(line,    words) {
    split(line, words)
    if ( words[4] ~ /}$/ ) { return words[5] }
    else { return words[4] }
}
function kname(line,    words) {
    split(line, words)
    if ( words[4] ~ /}$/ ) { return words[5] }
    else { return words[4] }
}
EOF

cleanup() {
    rm -f "$awklib"
}
trap cleanup ERR SIGTERM EXIT

case "$1" in
    atdef|macro|specialform|function|variable|constant|comparator|module|class|syntax|ftplugin)
        cmd="$1"
        shift
        build_"$cmd" "$@"
        ;;
    *)
        show_usage
        exit 1
        ;;
esac
