#!/usr/bin/env bash

author='Mitsuhiro Nakamura'
email='m.nacamura@gmail.com'
homepage='https://github.com/mnacamura/vim-gauche'

readonly author email homepage

read -r -d '' common_meta <<EOF
" Language: Scheme (Gauche)
" Last Change: $(date +"%Y-%m-%d")
" Author: $author <$email>
" URL: $homepage
" License: Public domain
" Notes: To enable this plugin, set filetype=scheme and (b|g):is_gauche=1.
EOF

set -euo pipefail

show_usage() {
    cat >&2 <<EOF
Usage: $0 CMD [ARG...]

Commands:
    tsv
    macro
    specialform
    function
    variable
    constant
    comparator
    module
    class
    syntax
    ftplugin
EOF
}

esc() {
    echo "$1" | sed -E 's@(\?|\*|\+|\.|\^|\$)@\\\1@g'
}

build_tsv() {
    if [ -z "${1+defined}" ]; then
        cat >&2 <<EOF
Usage: $0 tsv [NAME...]

Convert Gauche document source files to a TSV table.

Args:
    NAME...     names of texinfo source files, suffix (.texi) can be omitted
EOF
        exit 1
    fi

    local name files=()
    for name in "$@"; do
        files+=("$GAUCHE_SRC/doc/${name%.texi}.texi")
    done

    grep -E '^@def' "${files[@]}" \
        | sed 's/:/ /' \
        | awk -f"$lib" -e 'BEGIN { FS = " " }
                           { $1 = basename($1)
                             # Join fields surrounded by {}
                             for (i = 3; i <= NF; i++) {
                                 j = i
                                 while ( $i ~ /^{/ && $j !~ /}$/ ) {
                                     j++
                                     if ( j > NF ) break
                                 }
                                 if ( j > i )
                                     for ( k = i + 1; k <= j; k++ ) {
                                         $i = $i" "$k
                                         $k = ""
                                     }
                             }
                             print
                           }' \
        | sed -E 's/\t+/\t/g' \
        | awk -f"$lib" -e '{ if ( $3 ~ /^{.+}$/ )
                                 # $3 may have various cases:
                                 # e.g. {Condition Type} and {Condition type}
                                 print $1, $2, tolower($3), $4
                             else
                                 print $1, $2, $3
                           }' \
        | sort | uniq
}

build_macro() {
    if [ -z "${1+defined}" ]; then
        cat >&2 <<EOF
Usage: $0 macro FILE

Generate vim syntax for Gauche macros.

Args:
    FILE        path to the TSV file generated by $0 tsv
EOF
        exit 1
    fi

    local line name
    awk -f"$lib" -e '/@defmacx?/ { print libtype($1), $3 }' "$1" \
        | sort | uniq \
        | awk -f"$lib" -e '{ print_with_atat_expanded($0) }' \
        | while read -r line; do
              name="$(echo "$line" | awk -F'\t' '{ print $2 }')"
              if ! grep -E "syn keyword scheme\\w*Syntax $(esc "$name")" \
                  "$VIM_SRC"/runtime/syntax/scheme.vim > /dev/null 2>&1
              then
                  echo "$line"
              fi
          done \
        | awk -F'\t' '{ if ( $2 == "use" )
                            {}  # skip it as it is handled in schemeImport
                        else if ( $2 == "^c" )
                            print "syn match gauche"$1"Macro /\\^[_a-z]/"
                        else
                            print "syn keyword gauche"$1"Macro", $2
                      }'
}

build_specialform() {
    if [ -z "${1+defined}" ]; then
        cat >&2 <<EOF
Usage: $0 specialform FILE

Generate vim syntax for Gauche special forms.

Args:
    FILE        path to the TSV file generated by $0 tsv
EOF
        exit 1
    fi

    local line name
    awk -f"$lib" -e '/@defspecx?/ { print libtype($1), $3 }' "$1" \
        | sort | uniq \
        | awk -f"$lib" -e '{ print_with_atat_expanded($0) }' \
        | while read -r line; do
              name="$(echo "$line" | awk -F'\t' '{ print $2 }')"
              if ! grep -E "syn keyword scheme\\w*Syntax $(esc "$name")" \
                  "$VIM_SRC"/runtime/syntax/scheme.vim > /dev/null 2>&1
              then
                  echo "$line"
              fi
          done \
        | awk -F'\t' '{ if ( $2 == "import" )
                            {}  # skip it as it is handled in schemeImport
                        else
                            print "syn keyword gauche"$1"SpecialForm", $2
                      }'
}

build_function() {
    if [ -z "${1+defined}" ]; then
        cat >&2 <<EOF
Usage: $0 function FILE

Generate vim syntax for Gauche functions.

Args:
    FILE        path to the TSV file generated by $0 tsv
EOF
        exit 1
    fi

    local line name
    awk -f"$lib" -e '/@defunx?/ { print libtype($1), unwrap($3) }' "$1" \
        | sort | uniq \
        | awk -f"$lib" -e '{ print_with_atat_expanded($0) }' \
        | while read -r line; do
              name="$(echo "$line" | awk -F'\t' '{ print $2 }')"
              if ! grep -E "syn keyword schemeFunction $(esc "$name")" \
                  "$VIM_SRC"/runtime/syntax/scheme.vim > /dev/null 2>&1
              then
                  echo "$line"
              fi
          done \
        | awk -F'\t' '{ print "syn keyword gauche"$1"Function", $2 }'
}

build_variable() {
    if [ -z "${1+defined}" ]; then
        cat >&2 <<EOF
Usage: $0 variable FILE

Generate vim syntax for Gauche variables.

Args:
    FILE        path to the TSV file generated by $0 tsv
EOF
        exit 1
    fi

    local line name
    awk -f"$lib" -e '/@defvarx?/ { print libtype($1), $3 }' "$1" \
        | sort | uniq \
        | awk -f"$lib" -e '{ print_with_atat_expanded($0) }' \
        | while read -r line; do
              name="$(echo "$line" | awk -F'\t' '{ print $2 }')"
              if ! grep -E "syn keyword schemeConstant $(esc "$name")" \
                  "$VIM_SRC"/runtime/syntax/scheme.vim > /dev/null 2>&1
              then
                  echo "$line"
              fi
          done \
        | awk -F'\t' '{ print "syn keyword gauche"$1"Variable", $2 }'
}

build_constant() {
    if [ -z "${1+defined}" ]; then
        cat >&2 <<EOF
Usage: $0 constant FILE

Generate vim syntax for Gauche constants.

Args:
    FILE        path to the TSV file generated by $0 tsv
EOF
        exit 1
    fi

    local line name
    awk -f"$lib" -e '/@defvrx?/ && /{constant}/ {
                         print libtype($1), $4
                     }' "$1" \
        | sort | uniq \
        | awk -f"$lib" -e '{ print_with_atat_expanded($0) }' \
        | while read -r line; do
              name="$(echo "$line" | awk -F'\t' '{ print $2 }')"
              if ! grep -E "syn keyword schemeConstant $(esc "$name")" \
                  "$VIM_SRC"/runtime/syntax/scheme.vim > /dev/null 2>&1
              then
                  echo "$line"
              fi
          done \
        | awk -F'\t' '{ print "syn keyword gauche"$1"Constant", $2 }'
}

build_comparator() {
    if [ -z "${1+defined}" ]; then
        cat >&2 <<EOF
Usage: $0 comparator FILE

Generate vim syntax for Gauche comparators.

Args:
    FILE        path to the TSV file generated by $0 tsv
EOF
        exit 1
    fi

    local line name
    awk -f"$lib" -e '/@defvrx?/ && /{comparator}/ {
                         print libtype($1), $4
                     }' "$1" \
        | sort | uniq \
        | awk -f"$lib" -e '{ print_with_atat_expanded($0) }' \
        | while read -r line; do
              name="$(echo "$line" | awk -F'\t' '{ print $2 }')"
              if ! grep -E "syn keyword schemeConstant $(esc "$name")" \
                  "$VIM_SRC"/runtime/syntax/scheme.vim > /dev/null 2>&1
              then
                  echo "$line"
              fi
          done \
        | awk -F'\t' '{ print "syn keyword gauche"$1"Comparator", $2 }'
}

build_module() {
    if [ -z "${1+defined}" ]; then
        cat >&2 <<EOF
Usage: $0 module FILE

Generate vim syntax for Gauche modules.

Args:
    FILE        path to the TSV file generated by $0 tsv
EOF
        exit 1
    fi

    local line name
    awk -f"$lib" -e '/@deftpx?/ && /{(builtin )?module}/ { 
                         print libtype($1), $4
                     }' "$1" \
        | sort | uniq \
        | awk -f"$lib" -e '{ print_with_atat_expanded($0) }' \
        | awk -F'\t' '{ print "syn keyword gauche"$1"Module", $2 }'
}

build_class() {
    if [ -z "${1+defined}" ]; then
        cat >&2 <<EOF
Usage: $0 class FILE

Generate vim syntax for Gauche classes.

Args:
    FILE        path to the TSV file generated by $0 tsv
EOF
        exit 1
    fi

    local line name
    awk -f"$lib" -e '/@deftpx?/ && /{((builtin )?class|metaclass)}/ {
                         print libtype($1), $4
                     }' "$1" \
        | sort | uniq \
        | awk -f"$lib" -e '{ print_with_atat_expanded($0) }' \
        | awk -F'\t' '{ print "syn keyword gauche"$1"Class", $2 }'
}

build_syntax() {
    if [ "$#" -eq 0 ]; then
        cat >&2 <<EOF
Usage: $0 syntax [FILE...]

Generate syntax/gauche.vim from generated vim files.

Args:
    FILE...     path to file(s) generated by $0 (macro|specialform|...)
EOF
        exit 1
    fi

    cat <<EOF
" Vim syntax file
$common_meta

if !exists('b:did_scheme_syntax')
  finish
endif
EOF

    echo
    cat <<'EOF'
syn region schemeImport matchgroup=schemeImport start="\(([ \t\n]*\)\@<=\(import\|use\)\>" end=")"me=e-1 contained contains=schemeImportForm,schemeIdentifier,schemeComment,schemeDatumComment,gaucheBuiltinModule,gaucheExtModule,gaucheUtilModule

syn region gaucheSharpString start=/\(\\\)\@<!#"/ skip=/\\[\\"]/ end=/"/ contains=gaucheSharpStringUnquote
hi def link gaucheSharpString schemeString

syn region gaucheSharpStringUnquote matchgroup=schemeParentheses start=/\(\~\)\@<!\~\(\~\)\@!/ end=/[ `'\t\n\[\]()";]/me=e-1 contained contains=ALLBUT,schemeDatumCommentForm,@schemeImportCluster
syn region gaucheSharpStringUnquote matchgroup=schemeParentheses start=/\(\~\)\@<!\~#\?(/ end=/)/ contained contains=ALLBUT,schemeDatumCommentForm,@schemeImportCluster
syn region gaucheSharpStringUnquote matchgroup=schemeParentheses start=/\(\~\)\@<!\~\[/ end=/\]/ contained contains=ALLBUT,schemeDatumCommentForm,@schemeImportCluster
EOF

    local file
    for file in "$@"; do
        echo
        cat "$file"
    done

    echo
    cat <<EOF
hi def link gaucheBuiltinMacro schemeSyntax
hi def link gaucheBuiltinSpecialForm schemeSpecialSyntax
hi def link gaucheBuiltinFunction schemeFunction
hi def link gaucheBuiltinVariable schemeConstant
hi def link gaucheBuiltinConstant schemeConstant
hi def link gaucheBuiltinComparator schemeConstant
hi def link gaucheBuiltinModule Type

hi def link gaucheExtMacro schemeSyntax
hi def link gaucheExtSpecialForm schemeSpecialSyntax
hi def link gaucheExtFunction schemeFunction
hi def link gaucheExtVariable schemeConstant
hi def link gaucheExtConstant schemeConstant
hi def link gaucheExtComparator schemeConstant
hi def link gaucheExtModule Type

hi def link gaucheUtilMacro schemeSyntax
hi def link gaucheUtilSpecialForm schemeSpecialSyntax
hi def link gaucheUtilFunction schemeFunction
hi def link gaucheUtilVariable schemeConstant
hi def link gaucheUtilConstant schemeConstant
hi def link gaucheUtilComparator schemeConstant
hi def link gaucheUtilModule Type
EOF
}

build_ftplugin() {
    if [ "$#" -eq 0 ]; then
        cat >&2 <<EOF
Usage: $0 ftplugin [FILE...]

Generate ftplugin/gauche.vim from generated vim files.

Args:
    FILE...     path to file(s) generated by $0 (macro|specialform|...)
EOF
        exit 1
    fi

    cat <<EOF
" Vim filetype plugin file
$common_meta

if !exists('b:did_scheme_ftplugin')
  finish
endif

EOF

    local word
    awk '{ print $4 }' "$@" \
        | awk '/^(|r|g)let((|rec)(|1|\*)($|-)|\/)/ || /-let(|rec)(|1|\*)$/ \
            || /^define($|-)/ || /-define$/ \
            || /^match($|-)/ || /-match$/ \
            || /^(|e)case($|-)/ || ( /-(|e)case$/ && $0 !~ /(lower|upper|title)-case$/ ) \
            || /^lambda($|-)/ || ( /-lambda(|\*)$/ && $0 !~ /^scheme\.case-lambda$/ ) \
            || /^set!($|-)/ || ( /-set!$/ && $0 !~ /char-set!$/ ) \
            || /^do(-|times|list)/' \
        | sort | uniq \
        | while read -r word; do
              if ! grep -F "setl lispwords+=$word" \
                  "$VIM_SRC"/runtime/ftplugin/scheme.vim > /dev/null 2>&1
              then
                  echo "setl lispwords+=$word"
              fi
          done
}

if [ -z "${GAUCHE_SRC+defined}" ]; then
    echo "Please set GAUCHE_SRC to gauche source path" >&2
    exit 1
fi

if [ -z "${VIM_SRC+defined}" ]; then
    echo "Please set VIM_SRC to vim source path" >&2
    exit 1
fi

if [ -z "${1+defined}" ]; then
    show_usage
    exit 1
fi

lib="$(mktemp --suffix vimgauche)"
cat > "$lib" <<'EOF'
BEGIN {
    FS = "\t"
    OFS = "\t"
    atat[0] = "u8"
    atat[1] = "s8"
    atat[2] = "u16"
    atat[3] = "s16"
    atat[4] = "u32"
    atat[5] = "s32"
    atat[6] = "u64"
    atat[7] = "s64"
    atat[8] = "f16"
    atat[9] = "f32"
    atat[10] = "f64"
    atat[11] = "c32"
    atat[12] = "c64"
    atat[13] = "c128"
}
function basename(path,    _path) {
    _path = path
    sub(".*/", "", _path)
    return _path
}
function libtype(texifile) {
    if ( texifile ~ /(core|macro|object)/ )
        return "Builtin"
    if ( texifile ~ /gauche/ )
        return "Ext"
    if ( texifile ~ /r7rs/ )
        return "R7rs"
    if ( texifile ~ /srfi/ )
        return "Srfi"
    if ( texifile ~ /util/ )
        return "Util"
    return "Unknown"
}
function unwrap(field,    m) {
    if ( match(field, /^{\(\w+ (.+)\)}$/, m) )
        return m[1]
    return field
}
function print_with_atat_expanded(line,    i, _line) {
    if ( line ~ /@@/ )
        for (i in atat) {
            _line = line
            gsub(/@@/, atat[i], _line)
            print _line
        }
    else
        print line
}
EOF

cleanup() {
    rm -f "$lib"
}
trap cleanup ERR SIGTERM EXIT

case "$1" in
    tsv|macro|specialform|function|variable|constant|comparator|module|class|syntax|ftplugin)
        cmd="$1"
        shift
        build_"$cmd" "$@"
        ;;
    *)
        show_usage
        exit 1
        ;;
esac
